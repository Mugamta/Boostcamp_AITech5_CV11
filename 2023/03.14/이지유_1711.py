# [관찰1] 직각삼각형의 개수를 구하는 문제이다.
#         => 작각삼각형의 성질로는 1) 피타고라스 정리의 성립, 2) 내적의 결과값이 0 등이 존재한다.
#         => 두 성질 모두 검증을 위해서 반드시 직각삼각형을 이루는 세 점이 좌표가 필요하다.
#         => 가능한 모든 세 점의 조합을 탐색하여야 한다.
#         !=> 완전탐색이 가능한지 살펴보자.

# [관찰2] 점의 개수의 범위가 [3, 1500]이다.
#         => 가능한 모든 세 점의 조합의 개수는 combination(1500, 3) = 5.613755 × 10^8이다.
#             (컴퓨터는 1초에 1 × 10^8번 정도의 연산이 가능하고, 추어진 시간 제한은 5초이다.)
#         !=> 코드를 잘 짜면 완전탐색이 가능할 것 같다. 

# [관찰3] 주어지는 모든 점의 좌표는 다르다.
#         => 임의의 세 점은 반드시 삼각형을 이룬다.
#         !=> 임의의 세 점이 삼각형을 이루지 읺는 경우에 대한 예외 처리를 고려하지 않아도 된다. (e.g., (1, 1), (1, 1), (1, 1))

import sys

input = sys.stdin.readline

# 점의 개수를 입력받는다.
N = int(input())

# 점의 좌표를 입력받는다.
C = [list(map(int, input().split())) for _ in range(N)]

# 정답(i.e., 직각삼각형의 개수)를 초기화한다.
answer = 0

# (모든 경우의 수를 탐색하면서) 직각삼각형의 성질을 활용하여 정답을 갱신한다.
for t1 in range(N - 2):
    for t2 in range(t1 + 1, N - 1):
        for t3 in range(t2 + 1, N):
            # [정해] 피타고리스 정리
            h1 = (C[t1][0] - C[t2][0]) ** 2 + (C[t1][1] - C[t2][1]) ** 2
            h2 = (C[t2][0] - C[t3][0]) ** 2 + (C[t2][1] - C[t3][1]) ** 2
            h3 = (C[t3][0] - C[t1][0]) ** 2 + (C[t3][1] - C[t1][1]) ** 2
            
            if h1 == h2 + h3 or h2 == h1 + h3 or h3 == h1 + h2:
                answer += 1

            # [참고1]
            # if h1 + h2 + h3 == max(h1, h2,  h3) << 1:
            #     answer += 1

            # [참고2] 백터의 내적
            # ip1 = (C[t2][0] - C[t1][0]) * (C[t3][0] - C[t1][0]) + (C[t2][1] - C[t1][1]) * (C[t3][1] - C[t1][1])
            # ip2 = (C[t1][0] - C[t2][0]) * (C[t3][0] - C[t2][0]) + (C[t1][1] - C[t2][1]) * (C[t3][1] - C[t2][1])
            # ip3 = (C[t1][0] - C[t3][0]) * (C[t2][0] - C[t3][0]) + (C[t1][1] - C[t3][1]) * (C[t1][1] - C[t3][1])

            # if not (ip1 and ip2 and ip3):
            #     answer += 1

# 정답을 출력한다.
print(answer)
