"""
알아야 할 것 - 완호의 석차 (정렬?)
주의사항 - 인센티브를 받지 못하는 조건이 존재함

1. 점수의 합으로 정렬, 완호보다 합이 높은 점수들과 완호끼리 N^2을 거쳐 모두 비교 - 최대 O(N^2), 불가능
2. 특정 점수로 정렬하여 조건 탐색
완호보다 점수의 합이 낮은 사람은 볼 필요 없으므로, 큰 점수부터 보는 것이 이득
(완호보다 점수가 높으려면 첫 번째 혹은 두 번째 점수가 더 높아야 함)

첫 번째 점수를 기준으로 내림차순으로 정렬한다면
어떤 사원의 점수는 첫 번째 점수는 앞 사람보다 높을 수 없음
앞 사람보다 점수가 낮다면 두 번째 점수를 비교하여 인센티브를 받을 수 있는지 체크해야 함
(1, 3), (1, 2), (1, 4), (1, 1), (1, 5)는 비교하기 어려움 - 정렬

시간 복잡도를 줄이려면 바로 앞 사원까지의 데이터만 활용해서 처리해야함
앞 사람과 비교했을 때, 인센티브가 가능한지 확인해야함...
첫 번째 데이터가 내림차순이면 두 번째 데이터를 비교해야 함

두 수를 모두 내림차순으로 정렬한다면,
이전 사원의 점수를 (a, b)라고 하면, 다음 사원은 (a, b-1), (a-1, b-1) 등일 수 있다.
이때 a-1, b-1이 (a, b)와 비교되어야 하므로, 값이 a 이상일 때 가질 수 있는 최대의 값 b를 저장하는 식으로
값을 저장해나가야한다.
예를 들어 (6, 6), (6, 5), (6, 4), (5, 7), (5, 5)의 경우, a = 6, b= 6을 저장하고 있는다.
이후 (5, 5)는 (6, 6)으로 걸러내고, 앞 숫자가 5보다 작아지면 두 번째 수 중 최댓값인 7을 가지고 간다...

내림차순, 오름차순으로 정렬한다면, 이전 사원의 점수를 (a, b)라고 하면, 다음 사원은 다음과 같은 경우의 수를 가진다.
1. 첫 번째 점수가 a와 같다면 두 번째 점수가 같거나 크다. (즉, 인센티브가 가능하다.)
2. 첫 번째 점수가 a보다 작을 때는 두 번째 점수가 b보다 작을 수 있다.
3. 첫 번째 점수가 a보다 작지만 두 번째 점수가 b 이상일 수 있다. (인센티브를 받는다.)
정리하면, (내림차순, 오름차순)으로 정렬하면 두 번째 점수가 b 이상이여야 인센티브를 받을 수 있다.
또한, (4, 1), (4, 2), (3, 1), (2, 1)과 같은 경우가 있다.
이러한 경우를 위해 위와 마찬가지로 두 번째 점수의 최댓값을 저장하여, 두번째 점수가 이 점수 이상인 사원을 찾는다.

앞 방법은 첫 번째 숫자가 작아지는지도 체크해야하므로, 후자가 더 편리한 구현일 것이다.

"""

def solution(scores):
    answer = 1
    
    # 완호의 점수
    s1, s2 = scores[0]
    sum_s = s1 + s2
    
    scores.sort(key = lambda x: (-x[0], x[1]))
    
    second = 0  # 두 번째 점수이자 기준점
    
    for score in scores:
        if score[0] > s1 and score[1] > s2:  # 각 점수가 완호의 점수보다 크면 인센티브 불가, -1 리턴
            return -1
        
        # 점수는 (내림차순, 오름차순)이므로
        # 첫번째 점수가 같으면 앞 사람보다 두 번째 점수가 높음
        # 첫 번째 점수가 더 낮으면 두 번째 점수를 비교 - 더 낮으면 앞 사람보다 둘 다 낮으므로 인센티브 불가능
        if second <= score[1]:  # 인센티브를 받을 수 있는 사람
            if score[0] + score[1] > sum_s:  # 점수의 합이 완호의 점수보다 크면 석차에 계산
                answer += 1
            second = score[1]
    
    return answer