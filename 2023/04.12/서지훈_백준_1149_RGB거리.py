"""
19:35 문제 읽기 시작
비용의 최솟값 -> 동적계획법 혹은 그리디 알고리즘일 확률이 높음
N이 1000이며, 이웃한 집은 같은 색깔일 수 없음... 마지막 색깔을 기준으로 dp를 진행

i번째 집을 칠할 수 있는 경우는 i-1번째의 색깔을 제외한 두 가지
i번째 집을 R, G, B로 칠하는 경우까지의 최소 비용을 dp로 저장 - dp[N][3]

19:43 제출 - 정답

여담으로, i-1번째 집까지만 필요하므로 이전 집의 변수만 저장해두면 배열 필요 없음 -> 메모리 절약
대신 이전 집을 갱신하는 과정으로 시간은 조금 늘어남
"""

N = int(input())
dp = [[0, 0, 0] for i in range(N)]
dp[0][0], dp[0][1], dp[0][2] = map(int, input().split())
for i in range(1, N):
    R, G, B = map(int, input().split())

    dp[i][0] = R + min(dp[i - 1][1], dp[i - 1][2])
    dp[i][1] = G + min(dp[i - 1][0], dp[i - 1][2])
    dp[i][2] = B + min(dp[i - 1][0], dp[i - 1][1])

print(min(dp[N-1][0], dp[N-1][1], dp[N-1][2]))
