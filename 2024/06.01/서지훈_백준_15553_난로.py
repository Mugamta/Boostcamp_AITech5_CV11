"""
제약조건:
N, K가 최대 10만 -> O(NlogN, NlogK) 등의 형태로 해결 필요
T가 최대 10억 -> 값을 이용하지 않거나, log(T)를 이용한 이분 탐색 등으로 활용...

키워드:
시간 -> 정렬
최소 -> 그리디, BFS, DP 등

종합 -> 시간, 공간 복잡도를 고려하면 정렬 + 그리디 알고리즘일 확률이 높음

실제 문제 분석:
목표는 난로가 켜져 있는 시간의 최솟값
구사과는 방에 친구가 있을때만 난로를 켜며, 성냥(K개)를 이용하여 난로를 켬

친구가 존재할때 항상 난로를 켜야하지만, 난로의 개수에 제약이 있다.
시간 T가 최대 10억이므로 카운팅하는 방법은 불가능하다.

따라서, 우선 난로를 연속적으로 켜야 하는 시간을 저장한다.
이 결과, [1, 4], [6, 7], [10, 12]와 같은 형식의 시간대가 저장된다.
만약 여기서 성냥의 개수가 두 개라면, 이 세 시간대를 모두 켜는 것은 불가능하다.
따라서, 이 중 가장 시간 간격대가 짧은 [1, 4], [6, 7] 구간 사이에 성냥을 켜 둔다.

Python3 - 메모리 35756 KB, 시간 108ms
"""

from sys import stdin


def func():
    input = stdin.readline

    N, K = map(int, input().split())

    interval = []
    start, end = 0, 0  # 시작 시간대, 종료 시간대

    res = 0  # 결과값

    T = 0
    for _ in range(N):
        T = int(input())

        if end == 0:  # 시작 값인 경우, 시작, 끝 시간대 초기화
            start, end = T, T + 1

        # [1, 2], [2, 3]와 같이 시간대가 연속되는 경우, 성냥을 사용하지 않는 것이 유리
        elif end == T:
            end = T + 1  # 끝 시간만 갱신

        else:
            res += end - start  # 이외에는 시간 간격이 있으므로, 이 간격만큼의 시간대는 반드시 필요
            interval.append(T - end)  # 또한, 시간 간격을 추가함
            start, end = T, T + 1

    # 마지막으로 start, end를 추가한다.
    res += end - start
    interval.append(T + 1 - end)

    # 이제 시간대별 간격이 완성되었으므로, 이 간격 중 큰 시간대에 성냥을 배치해야 한다.
    interval.sort(reverse=True)  # 따라서, 우선 시간대별 간격을 내림차순으로 정렬한다.

    # 최소 한 번은 성냥을 켜야하므로, K - 1번의 성냥을 사용한다.
    res += sum(interval[K - 1:])

    print(res)


func()
