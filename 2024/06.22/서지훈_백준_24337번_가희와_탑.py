"""
제한조건:
N, a, b가 10^5 -> O(NlogN)

키워드:
건물의 높이, 볼 수 없음 -> 스택, 그리디 알고리즘
사전순 -> 정렬

실제 분석:
건물의 정보가 주어지는 것이 아니므로, 스택 문제는 아님
a에서 볼 수 있는 건물의 최대 높이가 b에서 볼 수 있는 마지막 높이가 됨
또한, 사전순이므로 각 건물의 숫자는 1부터 차례대로 배치함
따라서 그리디 알고리즘으로 a를 우선 배치한 후, b를 조건에 맞게 배치하는 형태?
"""
from collections import deque
from sys import stdin


def func():
    input = stdin.readline

    N, a, b = map(int, input().split())

    # 불가능한 경우는 두 수의 합이 N + 1을 넘는 경우
    # -> 한 쪽에서 보이는 건물이 X개라면, 1 ~ X까지의 건물이 존재하며, X번째 건물의 높이가 최대이다.
    # 즉 우측에서 보일 수 있는 건물의 수는 최대 N - X + 1개가 된다. (N - X개와, X번째 건물이 보임)

    if a + b > N + 1:
        print(-1)
        return

    answer = []

    # 사전순이므로, a의 건물은 1, 2, 3...의 형태로 가야한다.
    for i in range(1, a):  # a번째 건물은 b번째에서도 보일 수 있으므로, a - 1개만 우선 배치한다.
        answer.append(i)

    # 이제, 마지막으로 세울 건물은 b의 높이를 고려하여, a보다 b가 높다면 상관없으나, b가 더 높다면 b를 세워야 한다.
    answer.append(max(a, b))  # 따라서 둘 중 큰 것을 배치한다.

    # 이제 b - 1개의 건물을 내림차순으로 세우면 된다.
    for i in range(b - 1, 0, -1):
        answer.append(i)

    # N + 1 - a - b = 0이 아닐 수 있다.
    # 이 경우 추가적으로 건물이 필요한데, 사전순으로 앞서야 한다.
    # 따라서, 1을 배치하는 것이 유리하며, 앞에 배치할수록 유리하다.

    # 하지만, 10 1 2와 같은 경우, 2 1 1 1... 1이 되어야 한다.
    # 즉, 1이 첫번째가 아닌 경우가 있을 수 있으므로, 1을 첫번째 건물 바로 다음에 배치하자.
    # 이 경우, 첫 번째 건물이 1인 경우에는 1111...이 되며, 첫 번째 건물이 1이 아닌 경우에도 문제가 없다.

    answer = [answer[0]] + [1] * (N + 1 - a - b) + answer[1:]

    print(' '.join(map(str, answer)), end='')


func()
