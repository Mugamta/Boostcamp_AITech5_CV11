import sys


def func():
    T = int(sys.stdin.readline())

    # T가 십만개이므로, 이를 매 과정마다 구하는 것은 매우 비효율적일것이다.
    # 따라서, N = 100만인 경우까지 미리 구해놓고 사용해야 한다.

    # 하지만 N이 100만인 경우 sqrt(N)까지 계산해도 10^6 * 10^3 = 10^9으로 상당히 느리다.
    # 즉, 이를 좀 더 효율적으로 계산할 방법이 필요하다.

    # 수의 한계를 1000이라고 가정하자.
    # 1은 모든 수의 약수이므로, 약수의 합에서 총 천 번 등장한다.
    # 2는 500번 등장한다.
    # 3은 333번 등장한다...
    # 즉, 어떤 숫자 x가 숫자 n에서 등장하는 횟수는 n // x이다.
    # 따라서, 1 ~ n까지의 약수의 합은 (n // x) * x이다.

    # f(n)을 O(N^1.5) 대신 O(N)내에 구할 수 있음을 확인하였다.
    # 하지만 이 문제는 g(n)을 구해야 하므로, 여전히 O(N^2)이 요구된다.

    # g(6)와 g(2)를 비교하면, 3이 곱해진 형태이다.
    # 때문에 기존 약수의 합에 3이 더해진다.
    # g(8)과 g(2)를 비교하면 4가 곱해졌으므로 약수의 합에 4가 더해진다...

    # 위에서 더해지는 값을 2 ~ N이라고 가정하자. (1은 곱해도 의미 없으므로)
    # 이 경우, i가 곱해지는 기존 값을 j라고 하면, f(i * j)에는 i가 더해진다.
    # 또한, 자기 자신(g(6)과 g(2)에서 6과 같은 경우)또한 계산해주어야 한다.
    # 따라서 j는 1부터 순회되어야 하며, i * j가 N 이하여야 하므로 N // i까지만 계산하면 된다.
    # 이렇게 연산하면 N/2 + N/3 ... N / N으로, 총 연산 횟수는 12970034이다.

    # 단, for문을 많이 사용하는 관계로 python 대신 pypy로 제출해야 한다.

    N = 1000000

    g = [0] * (N + 1)
    g[1] = 1

    f = [1] * (N + 1)  # 공통 약수인 1은 리스트 생성때 더해준다.

    # 2 ~ N인 값에 대하여 배수를 계산하자.
    for i in range(2, N + 1):

        # 1 ~ (N // i)까지의 값까지 i * j가 유효하다.
        for j in range(1, (N // i) + 1):

            # f(j)의 약수에서 i를 곱하면 약수 i가 추가된다.
            f[i * j] = f[i * j] + i

        # g[i]는 모든 약수의 합이므로, 이전 값과의 누적 합으로 구한다.
        g[i] = g[i - 1] + f[i]

    for _ in range(T):
        N = int(sys.stdin.readline())
        sys.stdout.write(str(g[N]))
        sys.stdout.write("\n")


func()
