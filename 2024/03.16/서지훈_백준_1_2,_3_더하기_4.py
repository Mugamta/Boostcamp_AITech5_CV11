"""
각 테스트케이스마다 최대 n = 10000이며, 테스트케이스의 개수가 주어지지 않는다.
같은 n이라면 결과 값이 동일하므로, 미리 결과 값을 구해놓는 것으로 시간을 단축할 수 있다.

정수 n을 1, 2, 3의 합으로 나타내는 방법 구하기
0에서 시작하여 BFS로 1, 2, 3을 구하는 형태 -> 같은 수가 여러 번 반복될 수 있으므로 시간초과 발생
따라서 같은 수가 여러 개로 표현될 때 (4 = 1 + 1 + 1 + 1, 2 + 2...), 이를 효율적으로 구해야 함
이를 위해서는 모든 경우의 수를 직접 탐사하는 대신 이미 구해둔 경우의 수에서 곱하는 방식이 필요
즉, dp 문제인 것을 추론할 수 있음

"""


def func():
    T = int(input())

    # 합을 이루는 수의 순서만 다른 경우는 같은 것으로 친다...
    # 따라서 중복을 제거하기 위하여, 합을 이루는 각 숫자를 오름차순(비내림차순)인 경우만 고려하자.

    # 이 경우, 1으로 끝나는 합에 1을 더하는 경우, 2를 더하는 경우, 3을 더하는 경우...를 만들 수 있다.
    # 또한, 2로 끝나는 경우는 2를 더하는 경우, 3을 더하는 경우를 만들 수 있다.
    # 3으로 끝나는 경우는 3을 더하는 경우를 만들 수 있다.

    dp = [[0, 0, 0, 0] for _ in range(10001)]
    # dp[i][j]는 숫자 i를 만들 때, j로 끝나도록 만드는 경우의 수를 의미한다.
    dp[1][1] = 1
    dp[2] = [0, 1, 1, 0]
    dp[3] = [0, 1, 1, 1]

    for i in range(4, 10001):
        dp[i][1] = dp[i - 1][1]  # 1로 끝나는 합은 1에서 만들 수 있다.
        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]  # 2로 끝나는 합은 n - 2의 마지막이 1, 2인 경우 가능
        dp[i][3] = dp[i - 3][1] + dp[i - 3][2] + dp[i - 3][3]  # 3으로 끝나는 합은 n - 3의 마지막이 1, 2, 3인 경우

    for _ in range(T):
        n = int(input())
        print(sum(dp[n]))


func()
