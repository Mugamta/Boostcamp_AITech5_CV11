"""
N이 100만 -> N^2 불가능
~10억 ~ 10억의 값 -> 값을 이용하지 않거나, O(log)로 이용 -> 이분탐색

길이, 위치(좌표) -> 기하학, 피타고라스
겹쳐서 -> 좌표 기억 (자료구조)

실제 문제를 읽어보면 x, y가 수직선상의 좌표 구간 [x, y]를 의미해야 한다.
(x, y가 하나의 선이여야 하므로)
즉, -10억 ~ 10억 사이의 일정 구간이 채워져 있는데, 그 채워진 구간의 길이를 모두 구하는 것이다.

이 구간의 넓이를 모두 표현하려면, bool 자료형으로 표현해도 1GB를 넘으므로 메모리 제한이 초과된다.
즉, 제한된 메모리에서 이를 효율적으로 담을 방법이 필요하며, 특수한 자료구조를 사용해야 할 것으로 유추할 수 있다.

우선, N^2이 불가능하므로 정렬 후 순차적인 순회(스위핑)를 한다고 가정하자.
이 경우, 현재 순회하는 구간이 [x, y]라고 가정하면, 다음 구간과 합쳐지려면 nx <= y여야 한다.
이 경우 기존 구간의 [x, ny]로 구간을 확대한다. (x <= nx <= y <= ny)
만약 조건을 만족하지 않는다면 x, y로 구간을 마무리하므로 이 길이를 더하고, 현재 구간의 [nx, ny]를 새로 기준으로 지정한다.

따라서 알고리즘은 정렬 + 스위핑이 된다.
"""
import sys


def func():
    N = int(sys.stdin.readline())

    locates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]
    locates.sort()

    res = 0

    x, y = -1000000001, -1000000001
    for nx, ny in locates:
        if nx <= y:
            # 틀린 부분 -> y = ny로 갱신하도록 하였는데, 이 경우 ny가 y보다 작은 경우 (x 기준으로 우선 정렬되므로)
            # (1, 6), (2, 3)과 같은 경우, 6이 3으로 변경되어 틀렸고, 때문에 max를 취해주었음.
            y = max(y, ny)
        else:
            res += y - x
            x, y = nx, ny

    res += y - x
    print(res)


func()
