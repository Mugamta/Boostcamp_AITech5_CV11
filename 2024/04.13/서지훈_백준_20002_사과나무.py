"""
N이 300 이하이므로, O(N^2) 이상이 필요한 알고리즘일 것이다.
키워드 - 최대, 2차원 배열
최대는 dp, BFS, 그리디 등
2차원 배열은 BFS, DFS, 누적합 등

문제를 읽어보면, N x N 중 1 ~ N인 정사각형 구간을 골라, 이 중 최대가 되는 구간을 찾는다.

우선, 모든 값을 일일히 더한다고 가정하자.
1 x 1에서는 N^2을 탐색해야한다.
2 x 2에서는 (N-1)^2을 탐색해야 한다.
N x N에서는 (N - N + 1)^2을 탐색해야 한다.
즉, i * i크기의 구간을 탐색하려면 (N - i + 1) 만큼의 탐색이 필요하다.
i = 150이라면 최대 150^4이므로, 이 방법으로는 시간 초과가 발생한다.
따라서 이를 줄일 방법이 필요하다.

2차원 배열에서 이를 줄이는 방법은 대개 누적합이다.
누적합으로 (1, 1)에서 (X, Y)까지의 모든 합을 저장해둔 배열 N x N이 존재한다고 가정하자.

이 경우, i * i의 중간 배열은 구해놓은 누적합에서 (i, i)까지의 값을 우선 가져온다.
이후, 이 구간은 좌측/상측에 불필요한 값이 존재하므로 해당 부분의 값을 빼고, 공통적으로 담긴 좌측상단 값을 더한다.
따라서 arr[i][i] = 누적합[i][i] - 누적합[i][i - K] - 누적합[i - K][i] + 누적합[i - K][i - K]로 구할 수 있다.

이후, O(KXY)는 O(N^3)이내로 가능하므로, 2700만번 이내이다.
따라서 2초 내에 매우 충분히 해결할 수 있는 문제가 된다.
"""


def func():
    N = int(input())
    orchard = [list(map(int, input().split())) for _ in range(N)]

    # 누적합을 생성
    dp = [[0] * (N + 1) for _ in range(N + 1)]
    dp[1][1] = orchard[0][0]

    # 첫번째 줄을 생성
    for x in range(1, N + 1):
        dp[1][x] = dp[1][x - 1] + orchard[0][x - 1]

    for y in range(1, N + 1):
        dp[y][1] = dp[y - 1][1] + orchard[y - 1][0]

    # 이후 각 칸은 좌측까지의 합/위측까지의 합 - 겹치는 부분 + 현재 칸의 값으로 구성
    for y in range(1, N + 1):
        for x in range(1, N + 1):
            dp[y][x] = dp[y - 1][x] + dp[y][x - 1] - dp[y - 1][x - 1] + orchard[y - 1][x - 1]

    # 최소 값 대신 첫 칸의 값으로 간단하게 설정
    res = orchard[0][0]

    # 1 ~ N까지의 K에 대해서 순회
    for K in range(1, N + 1):
        for y in range(1, N + 1):
            # y가 K 이하인 경우, K 크기의 칸을 만들지 못하므로 제외
            if y < K:
                continue

            for x in range(1, N + 1):
                # 마찬가지로 x가 K 이하인 경우 제외
                if x < K:
                    continue

                # 이후 누적합과 비슷하게, 현재까지의 합 - 좌측 합 - 상측 합 + 겹치는 부분을 이용하여 합을 구함
                a = dp[y][x]
                b = dp[y - K][x]
                c = dp[y][x - K]
                d = dp[y - K][x - K]

                # 기록된 최댓값과 비교
                res = max(res, a - b - c + d)

    print(res)


func()
